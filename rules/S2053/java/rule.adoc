include::../description.adoc[]

include::../recommended.adoc[]

== Noncompliant Code Example

Below, the hashed password is not salted:

----
MessageDigest md = MessageDigest.getInstance("SHA-512");
byte[] hashedPassword = md.digest(passwordToHash.getBytes(StandardCharsets.UTF_8)); // Noncompliant
----

----
MessageDigest md = MessageDigest.getInstance("SHA-512");
md.update(passwordToHash.getBytes(StandardCharsets.UTF_8));
byte[] hashedPassword = md.digest(); // Noncompliant, only one "update()" call and "digest()" without parameters
----

----
MessageDigest md = MessageDigest.getInstance("SHA-512");
byte[] hashedPassword = md.digest(passwordToHash.getBytes(StandardCharsets.UTF_8)); // Noncompliant, no "update()" call
----

----
PBEKeySpec spec = new PBEKeySpec(chars); // Noncompliant, no salt as an argument
----

----
byte[] salt = "notrandom".getBytes();
PBEKeySpec spec = new PBEKeySpec(chars, salt); // Noncompliant, predictable salt
----

== Compliant Solution

Use ``++java.security.SecureRandom++`` to produce a unpredictable salt:

----
MessageDigest md = MessageDigest.getInstance("SHA-512");

SecureRandom random = new SecureRandom();
byte[] salt = new byte[16];
random.nextBytes(salt);

md.update(salt);

byte[] hashedPassword = md.digest(passwordToHash.getBytes(StandardCharsets.UTF_8)); // Compliant
----

----
byte[] salt = this.secureSalt();
PBEKeySpec spec = new PBEKeySpec(chars, salt); // Compliant
----

include::../see.adoc[]

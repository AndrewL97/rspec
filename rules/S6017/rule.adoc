{cpp}17 version of the standards introduces ``++if constexpr++``. If the ``++constexpr++`` keyword follows the ``++if++`` keyword in an if statement, then the ``++if++`` condition must be a constant and the ``++then++`` or ``++else++`` block is discarded at compile time, depending on the value of the constant.


More precisely, if the condition of an if constexpr statement in a template is not value-dependent after instantiation, the discarded statement is not instantiated. This behaviour enables to write some templates in a more readable way, without using complex patterns (eg: by using ``++std::enable_if++``) to make code compile. 


This rule points out where such patterns could simply be replaced by ``++if constexpr++``.


== Noncompliant Code Example

----
template<typename Type>
typename std::enable_if_t<std::is_arithmetic_v<Type>> process(Type&& type); // Noncompliant, this function can be combined with the one below

template<typename Type> 
typename std::enable_if_t<!std::is_arithmetic_v<Type>> process(Type&& type);

template <class It, class Distance>
void moveForward(It& it, Distance d, std::input_iterator_tag); // Noncompliant, this function can be combined with the one below

template <class It, class Distance, class T>
void moveForward(It& it, Distance d, T);

template <class It, class Distance>
void moveForward(It& it, Distance d) { // Wrapper of the "moveForward" functions
    moveForward(it, d, typename std::iterator_traits<It>::iterator_category{} );
}
----


== Compliant Solution

----
template<typename Type> 
void process(Type&& type) {
    if constexpr(std::is_arithmetic_v<type>) {
        // implementation
    } else {
        // implementation
    }
}

template <class It, class Distance>
void moveForward(It& it, Distance d) { // Modifications have been directly done inside the wrapper
    if constexpr (std::iterator_traits<It>::input_iterator_tag) {
        // implementation
    } else {
        // implementation
    }    
}
----


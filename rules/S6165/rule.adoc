Removing elements from a container that have a specific value or that follow a given predicate is something common. But to achieve that before {cpp}20, you would usually end up with following what is called the _erase-remove idiom_:

* Call ``++std::remove++`` or ``++std::remove_if++`` with, as parameters, the container and the criterion to fulfill
* Then call the container method ``++erase++`` on the result 

However, {cpp}20 introduced two new methods: ``++std::erase++`` and ``++std::erase_if++`` which allow you to do just that in a single call.


This rule raises an issue when ``++std::erase++`` or ``++std::erase_if++`` could be used to simplify the code.


== Noncompliant Code Example

----
void removeZeros(std::vector<int> &v) {
    v.erase(std::remove(v.begin(), v.end(), 0), v.end()); // Noncompliant
}

void removeOddNumbers(std::vector<int> &v) {
    v.erase(std::remove_if(v.begin(), v.end(), [](auto i) { return i%2 == 0; }), v.end()); // Noncompliant
}
----


== Compliant Solution

----
void removeZeros(std::vector<int> &v) {
    std::erase(v, 0);
}

void removeOddNumbers(std::vector<int> &v) {
    std::erase_if(v, [](auto i) { return i%2 == 0; });
}
----


Removing elements from a container that have a specific value or that follow a given predicate is something common. But before {cpp}20, this was not straightforward and the way to do this would depend on the type of your container:

* For sequence containers, you would end up with following what is called the _erase-remove idiom_:
** Call ``++std::remove++`` or ``++std::remove_if++`` with, as parameters, the container and the criterion to fulfill
** Then call the container method erase on the result

* For associative containers, you would have no other option than looping through all the elements by hand

However, {cpp}20 introduced two new methods: ``++std::erase++`` (for sequence containers only) and ``++std::erase_if++`` which erase all elements equal to a value or that satisfy a given predicate.


This rule raises an issue when ``++std::erase++`` or ``++std::erase_if++`` could be used to simplify the code.


== Noncompliant Code Example

----
void removeZeros(std::vector<int> &v) {
  v.erase(std::remove(v.begin(), v.end(), 0), v.end()); // Noncompliant
}

void removeOddNumbers(std::vector<int> &v) {
  v.erase(std::remove_if(v.begin(), v.end(), [](auto i) { return i%2 == 0; }), v.end()); // Noncompliant
}

void removeOddNumbers(std::unordered_map<std::string, int> &m) {
  auto it = m.begin();
  while (it != m.end()) { // Noncompliant
    if (it->second % 2 == 0) {
      it = m.erase(it);
    } else {
      ++it;
    }
  }
}
----


== Compliant Solution

----
void removeZeros(std::vector<int> &v) {
  std::erase(v, 0);
}

void removeOddNumbers(std::vector<int> &v) {
  std::erase_if(v, [](auto i) { return i%2 == 0; });
}

void removeOddNumbers(std::unordered_map<std::string, int> &m) {
  std::erase_if(m, [](auto item) { return item.second % 2 == 0; });
}
----


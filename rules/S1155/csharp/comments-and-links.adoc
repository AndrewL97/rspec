=== On 2015-05-20T15:31:39Z Ann Campbell Wrote:
\[~tamas.vajk] please fill in code samples.


Also, the description is a shallow modification of the Java version. The reasoning sounded plausible, but please verify that the efficiency argument is valid for C#.

=== On 2015-05-22T11:15:59Z Tamas Vajk Wrote:
Added a small sample.


The performance reasoning is not 100% true:

If you call ``++.Count()++`` on a ``++List<T>++``, it will cast the list to an ``++ICollection<T>++``, and call the ``++Count++`` property. Whereas an ``++.Any()++`` on a ``++List<T>++`` will get the underlying ``++IEnumerator++``, and call ``++GetNext()++`` on it. My feeling is that the second one is going to be slower, but I haven't done any measurements.


Also, an ``++IEnumerable++`` can be an abstraction on top of a database as well. In this case ``++.Any()++`` and ``++.Count()++`` are transformed to SQL, and the performance may depend on many things. It seems that ``++.Count()++`` performs better for SQL Server and Entity Framework: 2nd answer of \http://stackoverflow.com/questions/305092/which-method-performs-better-any-vs-count-0. But the samples there use predicates in the ``++.Any()++`` and ``++.Count()++``, which might also affect the performance.


So I would emphasize the intention and not the performance.

=== On 2015-05-22T12:17:46Z Ann Campbell Wrote:
\[~tamas.vajk], your response makes me wonder whether we should write the opposite rule (in addition to this one? instead of this one?).


That aside, I've made some edits. Please double-check me.

=== On 2015-05-22T12:40:40Z Tamas Vajk Wrote:
LGTM


I wouldn't write the opposite rule. The developer needs to know whatever he is doing. In case of an underlying database table, the queries always need performance profiling, so the developer will need to optimize that, and can suppress this warning if he finds that for performance reasons he needs to use ``++.Count() > 0++``.


For in-memory operations, the performance difference won't matter. Or if it does, then other micro-optimizations will have to be done as well.




=== On 2015-05-22T13:32:37Z Tamas Vajk Wrote:
\[~ann.campbell.2] I've added a new noncompliant code sample

=== On 2015-05-22T14:37:51Z Ann Campbell Wrote:
Okay [~tamas.vajk]

=== On 2015-05-26T11:35:52Z Tamas Vajk Wrote:
Added the ``++.Count() == 0++`` to the description and extended the code samples

=== On 2015-05-26T14:03:18Z Ann Campbell Wrote:
\[~tamas.vajk] the description talks about comparing .Count() to 0, but one of the code samples illustrates a comparison to 1.

=== On 2015-05-26T14:13:47Z Tamas Vajk Wrote:
\[~ann.campbell.2] You are right, I removed the comparison to ``++0++``.

=== On 2015-05-27T14:04:31Z Ann Campbell Wrote:
Thanks [~tamas.vajk]. I've merged the code blocks into one block each for Compliant and Noncompliant 

=== On 2015-06-01T14:30:42Z Ann Campbell Wrote:
I've updated the examples with ``++List<string>++``. Please double-check me.

=== On 2015-06-01T14:49:45Z Tamas Vajk Wrote:
\[~ann.campbell.2], I've changed the ``++List<string>++`` to ``++IEnumerable<string>++``, because the ``++List++`` has a ``++Count++`` property, so calling the ``++Count()++`` on it might not be the best example.

=== On 2015-06-01T17:49:45Z Ann Campbell Wrote:
okay, thanks [~tamas.vajk]

=== On 2017-03-02T15:45:13Z Valeri Hristov Wrote:
\[~ann.campbell.2], I updated the description a bit, could you please review?

include::../comments-and-links.adoc[]

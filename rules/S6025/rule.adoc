In order to save memory, unions allow you to use the same memory to store objects from a list of possible types as long as one object is stored at a time.

In C and in C++ prior to C++11, unions are restricted to trivial types.

Starting from C++11, it is possible to use unions with non-trivial types with the following limitations :

* You have to manually handle the lifetime of the active member, using placement new and explicit object destruction.
* You have to define special members like destructor and copy-constructor while taking into consideration the active member.

In some cases, code that fails to perfectly follow those rules may still compile, but lead to memory corruption.

C++17 introduced std::variant which can replace unions while removing this burden and the associated risk. As a safer and more readable alternative, they should be preferred.


== Noncompliant Code Example

----
#include <new> // Required for placement 'new'.

struct Point {
    Point() {}
    Point(int x, int y) : x(x), y(y) {}
    Point(const Point& p) : Point(p.x, p.y) {}
    int x, y;
};

union U {
  int z;
  double w;
  Point p; // Noncompliant: non-trivial type in Union
  U() {
    new(&p) Point();
  }
  U(const Point& p) {
    new(&this->p) Point(p);
  }
};

int g(U& u);

int f(const U &u1, const Point &p) {
    U u2 = p;
    return g(u2);
}
----


== Compliant Solution

----
#include <variant>

struct Point {
    Point() {}
    Point(int x, int y) : x(x), y(y) {}
    Point(const Point& p) : Point(p.x, p.y) {}
    int x, y;
};

using V = std::variant<int, double, Point>; // Compliant

int g(V& v);

int f(const V &v1, const Point &p) {
    V v2 = p;
    return g(v2);
}

----


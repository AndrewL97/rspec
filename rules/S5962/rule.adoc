Sometimes, you might want to make a thread run indefinitely in the background by not binding it to its creation scope. Even though calling ``++detach()++`` on an ``++std::thread++`` object would satisfy this need, it is not the easiest way to do it: There will be no direct way to monitor and communicate with the detached thread, the ``++std::thread++`` object is no longer associated to any thread.


An easier alternative to satisfy this need is giving the thread a global scope. This way the thread will run as long as the program does. The thread will not be bound to any scope. It is also possible to do it by giving the ``++std::thread++`` a scope that is big enough for your use case. For example, the program's main function.


== Noncompliant Code Example

----
void backgroundTask();
void startBackgroundTask(){
  // Assume you want the thread to run after the end of startBackgroundTask
  std::thread backgroundThread(backgroundTask);
  backgroundThread.detach(); // Noncompliant
}

----


== Compliant Solution

----
void  backgroundTask();
// joining_thread is a user-made thread wrapper that would join() automatically on scope exit.
// In C++20, you can use std::jthread for that purpose
joining_thread backgroundThread;


void startBackgroundTask(){
  // Assume you want the thread to run after the end of startBackgroundTask
  backgroundThread = std::move(joining_thread{backgroundTask});
}
----


== See

* https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#cp26-dont-detach-a-thread[{cpp} Core Guidelines CP.26] - Don't detach() a thread


C++14 has introduced transparent comparators: the function objects that support heterogeneous comparison (i.e., comparison of values of different types, such as `+std::string+` and `+char const *+`). Transparent comparators can in some cases improve the performance of lookup operations on the container because they obviate the conversion for the lookup argument.

Consider this code for an illustration:

----
std::map<std::string, int> m;
m.find("abc"); // Converts to std::string, potentially allocates memory
----
With transparent comparators, the previous code would not create an `+std::string+`, but directly compare keys in the map with the searched-for `+char const *+`. The transparent comparator is the one that declares a nested type named `+is_transparent+`. It is supposed to be able to compare heterogeneous object types, for instance, in this case, compare a `+char const *+` with an `+std::string+`, without performing any conversion.

----
// std::less<> is transparent, std::less<anything> is not
std::map<std::string, int, std::less<>> m;
m.find("abc"); // Directly compares the char const* with the keys, no conversion
----
Lookup functions (such as `+find+`, `+count+`, or `+lower_bound+`) invoke a pairwise comparison of the searched-for value and the elements of the container.

If the searched-for value is of a different type than the `+key_type+` of the container, you need to either convert it to the `+key_type+` or define a comparison function/operator that accepts arguments of these two different types. Otherwise, a potentially costly conversion will take place multiple times during the lookup (one for each comparison).

This rule triggers when a container, namely, `+std::set+`, `+std::multiset+`, `+std::map+`, and `+std::multimap+`,

* with elements of type `+A+` (`+key_type+`) and
* with a transparent comparator
* is searched for a value of type `+B+` that is different from `+A+` and
* there is no comparison function/operator overload available that could directly compare `+A+` and `+B+` and `+B+` and `+A+` (the lookup functions use both `+A < B+` and `+B < A+` variants).


== Noncompliant Code Example

----
struct B {
  int i = 0;
  B(int i) : i(i) {}
};
bool operator<(const B& a, const B& b) { return a.i < b.i; }

void f() {
  // std::less<> is a transparent comparator
  std::set<B, std::less<>> m = { B{1}, B{2}, B{3}, B{4} };
  m.find(3); // Noncompliant, leads to multiple conversions from int to B
}
----


== Compliant Solution

Option 1: Provide heterogeneous comparison overrides

----
struct B {
  int i = 0;
  B(int i) : i(i) {}
};
bool operator<(const B& a, const B& b) { return a.i < b.i; }
// Handle both argument orders
bool operator<(const int& i, const B& b) { return i < b.i; }
bool operator<(const B& b, const int& i) { return b.i < i; }

void f() {
  // std::less<> is a transparent comparator
  std::set<B, std::less<>> m = { B{1}, B{2}, B{3}, B{4} };
  m.find(3); // Compliant, the corresponding overloads of operator< will be used
}
----
Option 2: Use non-transparent comparator

----
struct C {
  int i = 0;
  C(int i) : i(i) {}
  bool operator<(const C& other) const { return i < other.i; }
};
void f() {
  // The default comparator std::less<C> is not transparent
  std::set<C> w = { C{1}, C{2}, C{3}, C{4} };
  s.find(3);// Compliant, 3 is converted to C only once -
            // on construction of the argument to find,
            // which takes const C& and nothing else
}
----


When using ``++sprintf++`` , it's up to the developer to make sure the size of the buffer to be written to is large enough to avoid buffer overflows. Buffer overflows can cause the program to crash at a minimum. At worst, a carefully crafted overflow can cause malicious code to be executed.


``++snprintf++`` is a safe alternative that takes the size of the buffer as an additional argument, preventing the function to overflow the buffer. It should be used instead.


This rule reports any use of sprintf unless it is an exception.


== Noncompliant Code Example

----
sprintf(str, "%s", message);   // Noncompliant; `str` buffer size is not checked and it is vulnerable to overflows
----


== Compliant Solution

----
snprintf(str, sizeof(str), "%s", message); // Prevent overflows by enforcing a maximum size for `str` buffer
----


== Exceptions

It is a very common and acceptable pattern to compute the required size of the buffer with a call to ``++snprintf++`` with the same arguments into an empty buffer (this will fail, but return the necessary size), then to call ``++sprintf++`` as the bound check is not needed anymore. Note that 1 needs to be added by the size reported by ``++snprintf++`` to account for the terminal null character.

----
size_t buflen = snprintf(0, 0, "%s", message);
char* buf = malloc(buflen) + 1; // For the final 0
sprintf(buf, "%s", message);{code}
----

== See

* https://www.owasp.org/index.php/Top_10-2017_A9-Using_Components_with_Known_Vulnerabilities[OWASP Top 10 2017 Category A9] - Using Components with Known Vulnerabilities
* http://cwe.mitre.org/data/definitions/676[MITRE, CWE-676] - Use of Potentially Dangerous Function
* http://cwe.mitre.org/data/definitions/119[MITRE, CWE-119] - Improper Restriction of Operations within the Bounds of a Memory Buffer
* https://www.sans.org/top25-software-errors/#cat2[SANS Top 25] - Risky Resource Management


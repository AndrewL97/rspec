=== Related: RSPEC-848

=== On 2014-10-22T18:58:33Z Nicolas Peru Wrote:
Seems to me that the first phrase and the first non compliant code example contradicts. 

=== On 2014-10-22T19:07:09Z Ann Campbell Wrote:
\[~nicolas.peru] twoThirds ends up with a value of 0.0, i.e. 0 cast to a float. How would you suggest I clarify?

=== On 2014-10-22T19:28:42Z Nicolas Peru Wrote:
\[~ann.campbell.2]I understand the 1st phrase as "Everything goes fine if you multiply /divide int and assign them to float/long" whereas you explain afterward that there are issues.

The 2nd phrase of the 1st ยง should be : You can assign this result to a long, double or float with automatic type conversion however if the result of int division is... 

=== On 2014-10-22T19:35:33Z Ann Campbell Wrote:
I get it now, [~nicolas.peru]. See what you think.

=== On 2014-11-26T20:20:38Z Freddy Mallet Wrote:
Just to be sure [~ann.campbell.2] and [~nicolas.peru], Findbugs rule ICAST_INT_2_LONG_AS_INSTANT, also checks method calls. Ex:

----
new Date(seconds * 1000)  //non compliant if seconds is an int value (because the Date constructor accepts a long value and so we might get an unexpected behavior
----

Is it the case with the current implementation ?

=== On 2014-11-27T06:51:09Z Nicolas Peru Wrote:
No, current implementation only check for assignement and variable initializers. I reopen the ticket to cover those cases.

=== On 2014-11-27T07:50:02Z Freddy Mallet Wrote:
The return statement should also be covered. I'm going to update the code snippets.

=== On 2016-09-30T16:22:15Z Jean-Christophe Collet Wrote:
Right now, the way it is worded, this rule doesn't address long integers. Assigning a ``++long++`` expression to a ``++float++`` or ``++double++`` has pretty much the same issues as ``++int++``.

Current implementation of Java scanner doesn't flag something like:

----
float f = 4l / 3;
----
I think we should cover this as well.

=== On 2016-12-11T17:50:54Z Nicolai Ommer Wrote:
I recently found a statement where this rule should have triggered in my opinion, but hasn't:

----
double dt2 = (1 / 2) * dt * dt * sigma * sigma; // dt, sigma are double
----
It turned out that as soon as there is double value in the statement, the rule is not triggered, i.e.

----
double a = 1 / 2 * 5.0;
----

=== On 2016-12-12T14:58:00Z Ann Campbell Wrote:
Hi Nicolai,


We greatly appreciate such feedback, but this isn't the proper venue. Please raise this on the https://groups.google.com/forum/?pli=1#!forum/sonarqube[SonarQube Google Group], which is monitored by the plugin developers. And when you do, make sure to mention which language you're talking about.



Thx!

